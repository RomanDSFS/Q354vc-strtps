import sys
import os

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "../../")))
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "../../auth_service")))

from fastapi import APIRouter, Depends, HTTPException, UploadFile, File
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import update
from database import get_db
from models import Startup, User
from pydantic import BaseModel
from typing import List, Optional
from auth_service.routes.auth import get_current_user
import shutil
import uuid
import httpx

from config import UPLOAD_DIR

router = APIRouter()
DUE_DILIGENCE_SERVICE_URL = "http://127.0.0.1:8005/kpi/analyze"

# ✅ 0. Pydantic-модель ответа
class StartupResponse(BaseModel):
    id: str
    company_name: str
    industry: str
    stage: str
    region: str
    min_check: float
    pitch_deck: Optional[str] = None
    contacts: str
    description: Optional[str] = None

    model_config = {"from_attributes": True}

# ✅ 1. Обновление профиля инвестора
@router.post("/investors/profile", summary="Обновить профиль инвестора", tags=["Startups"])
async def save_investor_profile(investor_data: dict, db: AsyncSession = Depends(get_db), current_user: dict = Depends(get_current_user)):
    if current_user["role"] != "investor":
        raise HTTPException(status_code=403, detail="Access denied")

    stmt = (
        update(User)
        .where(User.id == current_user["id"])
        .values(
            investor_type=investor_data.get("investor_type", []),
            investment_stage=investor_data.get("investment_stage", []),
            industry=investor_data.get("industry", []),
            region=investor_data.get("region", []),
            min_check=investor_data.get("min_check", 0)
        )
    )
    await db.execute(stmt)
    await db.commit()
    return {"message": "Investor profile updated successfully"}

# ✅ 2.Обновить профиль основателя
@router.post("/founders/profile", summary="Обновить профиль основателя", tags=["Startups"])
async def save_founder_profile(
    founder_data: dict, 
    db: AsyncSession = Depends(get_db), 
    current_user: dict = Depends(get_current_user)
):
    if current_user["role"] != "founder":
        raise HTTPException(status_code=403, detail="Access denied")

    """
    # Проверяем, существует ли стартап, связанный с этим пользователем
    result = await db.execute(select(Startup).filter(Startup.founder_id == current_user["id"]))
    startup = result.scalars().first()

    if not startup:
        raise HTTPException(status_code=404, detail="Стартап не найден")"""

    # Обновляем данные стартапа
    stmt = (
        update(Startup)
        .where(Startup.founder_id == current_user["id"])
        .values(
            stage=founder_data.get("stage"),
            industry=founder_data.get("industry", []),
            region=founder_data.get("region", []),
            min_check=founder_data.get("min_check", 0),
        )
    )
    await db.execute(stmt)
    await db.commit()

    return {"message": "Founder profile updated successfully"}

# ✅ 2. Создание стартапа
@router.post("/founders/startup", summary="Создать стартап", tags=["Startups"])
async def create_startup(startup_data: dict, db: AsyncSession = Depends(get_db), current_user: dict = Depends(get_current_user)):
    if current_user["role"] != "founder":
        raise HTTPException(status_code=403, detail="Access denied")

    startup = Startup(
        industry=startup_data["industry"],
        stage=startup_data["stage"],
        region=startup_data["region"],
        min_check=startup_data["min_check"],
        
    )

    db.add(startup)
    await db.commit()
    await db.refresh(startup)
    return {"message": "Startup created successfully", "startup_id": startup.id}

# ✅ 3.Загрузить Pitch Deck
@router.post("/founders/upload", summary="Загрузить Pitch Deck", response_model=dict, tags=["Startups"])
async def upload_pitch_deck(
    file: UploadFile = File(...), 
    db: AsyncSession = Depends(get_db), 
    current_user: dict = Depends(get_current_user)
):
    if current_user["role"] != "founder":
        raise HTTPException(status_code=403, detail="Access denied")

    # Генерируем уникальное имя файла
    file_ext = file.filename.split('.')[-1]
    file_id = f"{uuid.uuid4()}.{file_ext}"
    file_path = os.path.join(UPLOAD_DIR, file_id)

    # Сохраняем файл
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)

    # Обновляем ссылку на Pitch Deck в базе данных
    stmt = (
        update(Startup)
        .where(Startup.founder_id == current_user["id"])
        .values(pitch_deck=file_path)
    )
    await db.execute(stmt)
    await db.commit()

    return {"message": "Pitch deck uploaded successfully", "file_path": file_path}


# ✅ 4. Получение всех стартапов
@router.get("/", response_model=List[StartupResponse], summary="Получение всех стартапов", tags=["Startups"])
async def get_startups(db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Startup))
    return result.scalars().all()

# ✅ 5. Фильтрация стартапов
@router.post("/filter", response_model=List[StartupResponse], summary="Фильтрация стартапов", tags=["Startups"])
async def filter_startups(filters: dict, db: AsyncSession = Depends(get_db)):
    query = select(Startup)
    if filters.get("industry"):
        query = query.filter(Startup.industry.op("&&")(filters["industry"]))
    if filters.get("stage"):
        query = query.filter(Startup.stage.op("&&")(filters["stage"]))
    if filters.get("region"):
        query = query.filter(Startup.region.op("&&")(filters["region"]))
    if filters.get("min_check"):
        query = query.filter(Startup.min_check >= filters["min_check"])
    result = await db.execute(query)
    return result.scalars().all()

# ✅ 6. Получение информации о стартапе
@router.get("/{startup_id}", response_model=StartupResponse, summary="Получение информации о стартапе", tags=["Startups"])
async def get_startup_detail(startup_id: str, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Startup).filter(Startup.id == startup_id))
    startup = result.scalars().first()
    if not startup:
        raise HTTPException(status_code=404, detail="Стартап не найден")
    return StartupResponse.model_validate(startup)

# ✅ 7. Отправка стартапа в Due Diligence
@router.post("/select/{startup_id}", summary="Отправить стартап в Due Diligence", tags=["Startups"])
async def submit_due_diligence(startup_id: str, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Startup).filter(Startup.id == startup_id))
    startup = result.scalars().first()
    
    if not startup:
        raise HTTPException(status_code=404, detail="Стартап не найден")

    payload = {
        "startup_id": startup.id,
        "company_name": startup.company_name,
        "industry": startup.industry,
        "stage": startup.stage,
        "region": startup.region,
        "min_check": startup.min_check
    }

    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(DUE_DILIGENCE_SERVICE_URL, json=payload)
            response.raise_for_status()
            return {"message": "Стартап успешно отправлен в Due Diligence", "response": response.json()}
        except httpx.HTTPStatusError as e:
            raise HTTPException(status_code=response.status_code, detail=f"Due Diligence error: {e.response.text}")

# ✅ 8. Получение списка подходящих стартапов для инвестора
@router.get("/matches/{investor_id}", summary="Получить список стартапов, подходящих инвестору", tags=["Startups"])
async def get_matching_startups(investor_id: str, db: AsyncSession = Depends(get_db)):
    investor = await db.execute(select(User).filter(User.id == investor_id, User.role == "investor"))
    investor = investor.scalars().first()
    if not investor:
        raise HTTPException(status_code=404, detail="Инвестор не найден")

    matching_startups = await db.execute(
        select(Startup).filter(
            Startup.industry.op("&&")(investor.industry),
            Startup.stage.op("&&")(investor.investment_stage),
            Startup.region.op("&&")(investor.region),
            Startup.min_check >= investor.min_check
        )
    )
    return {"message": "Найденные стартапы", "startups": [s.id for s in matching_startups.scalars().all()]}

# ✅ 2.Обновить профиль основателя
@router.post("/founders/profile", summary="Обновить профиль основателя", tags=["Startups"])
async def save_founder_profile(
    founder_data: dict, 
    db: AsyncSession = Depends(get_db), 
    current_user: dict = Depends(get_current_user)
):
    if current_user["role"] != "founder":
        raise HTTPException(status_code=403, detail="Access denied")

    """
    # Проверяем, существует ли стартап, связанный с этим пользователем
    result = await db.execute(select(Startup).filter(Startup.founder_id == current_user["id"]))
    startup = result.scalars().first()

    if not startup:
        raise HTTPException(status_code=404, detail="Стартап не найден")"""

    # Обновляем данные стартапа
    stmt = (
        update(Startup)
        .where(Startup.founder_id == current_user["id"])
        .values(
            stage=founder_data.get("stage"),
            industry=founder_data.get("industry", []),
            region=founder_data.get("region", []),
            min_check=founder_data.get("min_check", 0),
        )
    )
    await db.execute(stmt)
    await db.commit()

    return {"message": "Founder profile updated successfully"}

